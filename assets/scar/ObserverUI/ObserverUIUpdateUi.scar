import("ObserverUI/Settings.scar")

_ObserverUIDataContext = {
	players = {},
	playersById = {},
	EfficiencyStatisticsDisplayModeCommand = UI_CreateCommand("EfficiencyStatisticsDisplayModeCommand")
}

ObserverUi_ResourceMapping = {
	food = RT_Food,
	wood = RT_Wood,
	gold = RT_Gold,
	stone = RT_Stone
}

function AdaptIconPathForXaml(iconPath)
	return string.format("pack://application:,,,/WPFGUI;component/%s.png", string.gsub(iconPath, "\\", "/" ))
end

_AgeIconsForAnimation = {
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_1"), 
		[true] = AdaptIconPathForXaml("icons/hud/age/age_display_afford_1")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_2"),
		[true] = AdaptIconPathForXaml("icons/hud/age/age_display_afford_2")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_3"),
		[true] = AdaptIconPathForXaml("icons/hud/age/age_display_afford_3")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_4"),
		[true] = AdaptIconPathForXaml("icons/hud/age/age_display_afford_4")}
}

_AgeIcons = {
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_1"), 
		[true] = AdaptIconPathForXaml("icons/races/common/abilities/age_1")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_2"),
		[true] = AdaptIconPathForXaml("icons/races/common/abilities/age_2")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_3"),
		[true] = AdaptIconPathForXaml("icons/races/common/abilities/age_3")},
	{	[false] = AdaptIconPathForXaml("icons/hud/age/age_display_persistent_4"),
		[true] = AdaptIconPathForXaml("icons/races/common/abilities/age_4")}
}

_RaceImage = {
	abbasid = AdaptIconPathForXaml("images/civ_flags/flag_abbasid"),
	chinese = AdaptIconPathForXaml("images/civ_flags/flag_chinese"),
	english = AdaptIconPathForXaml("images/civ_flags/flag_english"),
	french = AdaptIconPathForXaml("images/civ_flags/flag_french"),
	hre = AdaptIconPathForXaml("images/civ_flags/flag_hre"),
	mongol = AdaptIconPathForXaml("images/civ_flags/flag_mongol"),
	rus = AdaptIconPathForXaml("images/civ_flags/flag_rus"),
	sultanate = AdaptIconPathForXaml("images/civ_flags/flag_sultanates"),
	malian = AdaptIconPathForXaml("images/civ_flags/flag_malian"),
	ottoman = AdaptIconPathForXaml("images/civ_flags/flag_ottoman")
} 

function InitializeObserverUIDataContext()
	local observerUIDataContext = _ObserverUIDataContext
	observerUIDataContext.ShowEfficiencyStatisticsInPercent = ObserverUI_Settings.ShowEfficiencyStatisticsInPercent
	
	for index, playerTable in pairs(PLAYERS) do
		local raceName = Player_GetRaceName(playerTable.id)
		
		 local data = {
			name = playerTable.playerName,
			color = UI_GetColourAsString(Player_GetUIColour(playerTable.id)),
			
			civIcon = AdaptIconPathForXaml(World_GetRaceIcon(playerTable.race)),
			civImage = _RaceImage[raceName],
			
			ageIcon = "",
			ageIconForAnimation = "",
			isUpping = false,
			ageUpProgress = 0.0,
			upAt = 0,
			populationVsMaximumPopulation = "",
			workerPopulation = 0,
			idleWorkerPopulation = 0,
			militaryPopulation = 0,
			siegePopulation = 0,
			relics = 0,
			relicsDeposited = 0,
			upgradesQueued = {},
			units = {},
			unitsWorkers = {},
			civSpecifics = { visible = raceName == "rus", icon = AdaptIconPathForXaml("icons/races/rus/abilities/hunting_boon"), text = "0"},
			WorkerIdleTime = 0,
			WorkerEfficiency = 0,
			TownCenterIdleTime = 0,
			TownCenterEfficiency = 0
		}
		
		local resources = {}
		for key,enum in pairs(ObserverUi_ResourceMapping) do
			resources[key] = {amount=0, workers=0, income="", icon=AdaptIconPathForXaml("icons/resources/resource_"..key.."_icon")}
		end
		
		data.resources = resources
		
		observerUIDataContext.players[index] = data
		observerUIDataContext.playersById[playerTable.id.PlayerID] = data
	end
	_ObserverUIDataContext.messages = {}
	
	PrepareObserverUIDataContextFor1v1()
end

function PrepareObserverUIDataContextFor1v1()
	if World_GetPlayerCount() ~= 2 then
		return
	end
	
	_ObserverUIDataContext.symmetricalUi = ObserverUI_Settings.symmetricalUi
	
	local startingPositionPlayer1 = Player_GetStartingPosition(PLAYERS[1].id)
	local startingPositionPlayer2 = Player_GetStartingPosition(PLAYERS[2].id)
	local Players1v1SwapPlayersDueToStartingPosition
		= startingPositionPlayer1.z - startingPositionPlayer1.x <
		  startingPositionPlayer2.z - startingPositionPlayer2.x
		
	if Players1v1SwapPlayersDueToStartingPosition ~= ObserverUI_Settings.swapPlayers1v1 then 
		_ObserverUIDataContext.player1 = _ObserverUIDataContext.players[2]
		_ObserverUIDataContext.player2 = _ObserverUIDataContext.players[1]
		return
	end
	
	_ObserverUIDataContext.player1 = _ObserverUIDataContext.players[1]
	_ObserverUIDataContext.player2 = _ObserverUIDataContext.players[2]
end

function SwapPlayers1v1()
	ObserverUI_Settings.swapPlayers1v1 = not ObserverUI_Settings.swapPlayers1v1
	PrepareObserverUIDataContextFor1v1()
	UpdateObserverUIDataContext()
end

function ToggleSymmetricalUi()
	ObserverUI_Settings.symmetricalUi = not ObserverUI_Settings.symmetricalUi
	PrepareObserverUIDataContextFor1v1()
	UpdateObserverUIDataContext()
end

function EfficiencyStatisticsDisplayModeCommand()
	ObserverUI_Settings.ShowEfficiencyStatisticsInPercent = not ObserverUI_Settings.ShowEfficiencyStatisticsInPercent
	_ObserverUIDataContext.ShowEfficiencyStatisticsInPercent = ObserverUI_Settings.ShowEfficiencyStatisticsInPercent
	UpdateObserverUIDataContext()
end

function UpdateObserverUIDataContext()
	for index, playerTable in pairs(_ObserverUIDataContext.players) do
		local player = PLAYERS[index].id
		
		local age = Player_GetCurrentAge(player)
		UpdateIsUpping(playerTable, player, age)
		playerTable.ageIcon = _AgeIcons[age][playerTable.isUpping]
		playerTable.ageIconForAnimation = _AgeIconsForAnimation[age][playerTable.isUpping]
		
		UpdateResources(playerTable, player)
		
		playerTable.populationVsMaximumPopulation = GetPopulationVsMaximumPopulation(player)
		
		UpdatePopulationComposition(playerTable, player)
		UpdateRelics(playerTable, player)
		UpdateUnitsAndQueuedStuff(playerTable, player, PLAYERS[index].race)
		UpdateCivSpecifics(playerTable, player)
		UpdateEfficiencyStatistics(playerTable, player)
	end
	
	UpdateMessages()
end

function UpdateResources(t, player)
	local resources = Player_GetResources(player)
	
	local tResources = t.resources
	for key,enum in pairs(ObserverUi_ResourceMapping) do
		tResources[key].amount = resources[key]
		tResources[key].workers = Player_GetStateModelInt(player, "num_"..key.."_gatherers")
		tResources[key].income = tostring(math.floor(Player_GetResourceRate(player, enum)*60)).."/min"
	end
end

function GetPopulationVsMaximumPopulation(player)
	local getCurrentPopulationCap = Player_GetCurrentPopulationCap
	if not getCurrentPopulationCap then
		getCurrentPopulationCap = Player_GetMaxPopulation
	end
	
	local maxPop = getCurrentPopulationCap(player, CT_Personnel)
	local curPop = Player_GetCurrentPopulation(player, CT_Personnel)
	
	return math.floor(curPop) .. "/" .. math.floor(maxPop)
end

function UpdatePopulationComposition(t, player)
	t.workerPopulation, t.idleWorkerPopulation, t.militaryPopulation, t.siegePopulation
		= PopulationComposition:GetForPlayer_Worker_WorkerIdle_MilitaryNonSiege_Siege(player)
end

function UpdateRelics(t, player)
	t.relics, t.relicsDeposited = RelicLocations:GetForPlayer_Carried_Deposited(player)
end

function DismissErrors(default, func)
    local success, result = pcall(func)
    if success then
        return result
    end
    
    return default
end

function GetIconNameFromSquadBlueprintUnsafe(pbg, race)
	return BP_GetSquadUIInfo(pbg, race).iconName
end

function GetIconNameFromSquadBlueprint(pbg, race)
    return DismissErrors(nil, function() return GetIconNameFromSquadBlueprintUnsafe(pbg, race) end)
end

function GetIconNameFromUpgradeBlueprintUnsafe(pbg)
	return BP_GetUpgradeUIInfo(pbg).iconName
end

function GetIconNameFromUpgradeBlueprint(pbg)
    return DismissErrors(nil, function() return GetIconNameFromUpgradeBlueprintUnsafe(pbg) end)
end

function HasMilitaryIcon(bp, race)
	return BP_GetSquadUIInfo(bp, race).tooltipDataTemplate == "BuildingMilitaryDataTemplate"
end

function GetUnits(player, race)
	local ownedSquads = OwnedSquads:GetForPlayer(player)
	local military = {}
	local civil = {}
	for _, stuff in pairs(ownedSquads) do
        local icon = GetIconNameFromSquadBlueprint(stuff.Bp, race)
		if icon then
			icon = AdaptIconPathForXaml(icon)
			if HasMilitaryIcon(stuff.Bp, race) then
				table.insert(military, {icon = icon, count = stuff.Count})
			else
				table.insert(civil, {icon = icon, count = stuff.Count})
			end
		end
	end
	
	return military, civil
end

function GetQueuedStuff(player, race)
	local queuedStuff = QueuedStuff:GetForPlayer(player)
	local upgradesQueued = {}
	local militaryQueued = {}
	local civilQueued = {}
	for _, stuff in pairs(queuedStuff) do
		if stuff.Bp.PropertyBagGroupType == PBGTYPE_Upgrade then
        	table.insert(upgradesQueued, {icon = AdaptIconPathForXaml(GetIconNameFromUpgradeBlueprint(stuff.Bp))})
		elseif stuff.Bp.PropertyBagGroupType == PBGTYPE_Squad then
			local icon = GetIconNameFromSquadBlueprint(stuff.Bp, race)
			if icon then
				icon = AdaptIconPathForXaml(icon)
				if HasMilitaryIcon(stuff.Bp, race) then
					table.insert(militaryQueued, {icon = icon, count = stuff.Count})
				else
					table.insert(civilQueued, {icon = icon, count = stuff.Count})
				end
			end
		end
	end
		
	return militaryQueued, civilQueued, upgradesQueued
end

function TakeQueuedUnitsCount(queue, icon)
	for i = 1, #queue do
		if queue[i].icon == icon then
			local count = queue[i].count
			queue[i].count = 0
			return count
		end
	end
	return 0
end

function BuildUnitsUiTable(units, queue)
	for i = 1, #units do
		units[i].queued = TakeQueuedUnitsCount(queue, units[i].icon)
	end
	for i = 1, #queue do
		if queue[i].count ~= 0 then
			queue[i].queued = queue[i].count
			queue[i].count = 0
			table.insert(units, queue[i])
		end
	end
	return units
end

function UpdateUnitsAndQueuedStuff(t, player, race)
	local military, civil = GetUnits(player, race)
	local militaryQueued, civilQueued, upgradesQueued = GetQueuedStuff(player, race)
								
	local militaryUi = BuildUnitsUiTable(military, militaryQueued)
	local civilUi = BuildUnitsUiTable(civil, civilQueued)
	for i = 1, #militaryUi do militaryUi[i].civil = false end
	for i = 1, #civilUi do civilUi[i].civil = true end
	
	t.upgradesQueued = upgradesQueued
	t.units = militaryUi
	t.unitsWorkers = civilUi
end

function UpdateIsUpping(t, player)
	t.isUpping, t.ageUpProgress, t.upAt = 
		AgingUpProgress:GetForPlayer_IsAgingUp_Progress_EstimatedTimeOfCompletion(player)
end

function UpdateCivSpecifics(t, player)
	if Player_GetRaceName(player) ~= "rus" then
		return
	end
	
	t.civSpecifics.text = tostring(math.floor(Player_GetStateModelFloat(player, "master_hunter_bounty_total_rus")))
end

function UpdateEfficiencyStatistics(playerTable, player)
	playerTable.TownCenterIdleTime, playerTable.TownCenterEfficiency = TownCenterIdling:GetForPlayer_IdleTime_Efficiency(player)
	playerTable.TownCenterEfficiency = string.format("%.1f%%", playerTable.TownCenterEfficiency * 100)
	playerTable.WorkerIdleTime, playerTable.WorkerEfficiency = WorkerIdling:GetForPlayer_IdleTime_Efficiency(player)
	playerTable.WorkerEfficiency = string.format("%.1f%%", playerTable.WorkerEfficiency * 100)
end

AGE_TO_TEXT = {
	[1] = "Dark Age",
	[2] = "Feudal Age",
	[3] = "Castle Age",
	[4] = "Imperial Age"
}

function UpdateMessages()
	local playersById = _ObserverUIDataContext.playersById
	local messages = AgingUpTimings:GetMessages()
	local messagesUi = {}
	
	for _, message in ipairs(messages) do
		local messageUi = {}
		if message.MessageType == AgingUpTimings.OBSERVERUI_MESSAGE_TYPE_AGING_UP_TIME_DIFFERENCE then
			messageUi.messageType = "ObserverUIMessageAgingUpTimeDifferenceBetween"
			
			messageUi.text = Player_GetDisplayName(message.FirstPlayer).LocString .. " < " .. 
				Player_GetDisplayName(message.SecondPlayer).LocString .. ": " .. tostring(message.Difference)
			
			messageUi.firstPlayerName = playersById[message.FirstPlayer.PlayerID].name
			messageUi.firstPlayerColor = playersById[message.FirstPlayer.PlayerID].color
			messageUi.secondPlayerName = playersById[message.SecondPlayer.PlayerID].name
			messageUi.secondPlayerColor = playersById[message.SecondPlayer.PlayerID].color
			messageUi.timeDifference = message.Difference
			messageUi.age = AGE_TO_TEXT[message.Age]
			
		elseif message.MessageType == AgingUpTimings.OBSERVERUI_MESSAGE_TYPE_AGING_UP_CAN_AFFORD_TIME then
			messageUi.messageType = "ObserverUIMessageAgingUpCanAffordTime"
			
			messageUi.text = Player_GetDisplayName(message.Player).LocString .. ": " .. tostring(message.Difference)
			
			messageUi.playerName = playersById[message.Player.PlayerID].name
			messageUi.playerColor = playersById[message.Player.PlayerID].color
			messageUi.timeDifference = message.Difference
		end
		
		table.insert(messagesUi, messageUi)
	end
	
	_ObserverUIDataContext.messages = messagesUi
end
